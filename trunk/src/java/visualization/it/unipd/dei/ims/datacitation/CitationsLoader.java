package it.unipd.dei.ims.datacitation;
import java.io.File ;
import java.nio.file.Files ;
import java.nio.file.Paths ;  
import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

import it.unipd.dei.ims.datacitation.config.InitDataCitation;

public class CitationsLoader  {

	//the groundtruth eadfiles folder
	private String gtEadFolderPath ;


	//the machine readable references of the ground truth 
	private String gtTestFolderPath ;
	//the output machine readable references generated by the "learning to cite" framework
	private String outputFolderPath ;

	private String [] gtFilePaths ;
	private String [] outputFilePaths;
	private String [] gtFilenames ;
	private String [] outputFilenames;
	
	
	private CitationsPair [] citPairs ; 


	public CitationsLoader () throws IOException {
		InitDataCitation prop = new InitDataCitation();
		
		try {
			prop.loadProperties();
		} catch (IOException e) {
			e.printStackTrace();
		}
		gtEadFolderPath = prop.getProperty ( "datacitation.path.testset");
		gtTestFolderPath = prop.getProperty ("datacitation.path.testset") + "_machine_ref";
		outputFolderPath = prop.getProperty ("datacitation.path.outputDir");
		/*
		System.out.println(gtEadFolderPath);
		System.out.println(gtTestFolderPath);
		System.out.println(outputFolderPath);
		*/
		
		File gtTestFolder = new File (gtTestFolderPath);
		File outputFolder = new File (outputFolderPath) ;

		int gtFilesNum = 0; int outputFilesNum = 0  ;
		System.out.println(gtTestFolderPath);
		for ( final File f : gtTestFolder.listFiles()){
			if ( f.exists() && !f.isHidden())
				gtFilesNum++;
		}

		for ( final File f : outputFolder.listFiles()){
			if ( f.exists() && !f.isHidden() && f.getName().endsWith(".txt"))
				outputFilesNum++;
		}

		int filesNum = 0; 
		if ( gtFilesNum != outputFilesNum ) {
			String e = "the ground truth and output folders have a different number of files. "+
			gtFilesNum+" "+outputFilesNum+" ";
			throw new IOException(e);

		}else{
			filesNum = gtFilesNum;
		}

		gtFilePaths = new String [filesNum];
		outputFilePaths = new String [filesNum];
		gtFilenames = new String [filesNum];
		outputFilenames = new String [filesNum];

		int i = 0 ; 
		for ( final File f : gtTestFolder.listFiles()){
			if ( f.exists() && !f.isHidden()){
				gtFilePaths[i] = f.getAbsolutePath();
				gtFilenames[i] = f.getName();
				i++;
			}
		}
		i = 0 ;
		for ( final File f : outputFolder.listFiles() ){
			if ( f.exists() && !f.isHidden() && f.getName().endsWith(".txt")){
				outputFilePaths[i] = f.getAbsolutePath();
				outputFilenames[i] = f.getName();
				i++;
			}
		}

		Arrays.sort(gtFilePaths);Arrays.sort(gtFilenames);
		Arrays.sort(outputFilePaths);Arrays.sort(outputFilenames);
		/*
		for ( int j = 0 ; j < gtFilePaths.length ; j++ ) {

			System.out.println("gtFilePaths["+Integer.toString(j)+"] : "+gtFilePaths[j]) ;
			System.out.println("outputFilePaths["+Integer.toString(j)+"] : "+outputFilePaths[j]) ;
		}
		*/


		
		citPairs = new CitationsPair [filesNum];
		for ( int k = 0 ; k < gtFilePaths.length;k++ ){
			String gtmr = readFile(gtFilePaths[k]);
			String mr = readFile(outputFilePaths[k]);
			String [] gtsplt = gtFilenames[k].split("-");
			String [] splt = outputFilenames[k].split("-");

			
			if (gtsplt[0].equals(splt[0]) && gtsplt[1].equals(splt[1]) ){

				String onlyHaNA = "" ;

				if ( gtsplt[1].contains("HaNA")) onlyHaNA = "-"+gtsplt[2];

				String xpathFilePath = prop.getProperty("datacitation.path.testset") + "_XPath/"+
				splt[0]+"-"+splt[1]+onlyHaNA+"-xpath.txt";

				System.out.println(xpathFilePath);

				String xpath = readFile(xpathFilePath);

				if ( gtsplt[1].contains("HaNA")) onlyHaNA = "-"+gtsplt[1]; else onlyHaNA = "";
				String eadFilePath = gtEadFolderPath+"/"+gtsplt[0]+onlyHaNA+".xml";

				citPairs[k] = new CitationsPair(gtmr,mr,eadFilePath,gtsplt[0]+"-"+gtsplt[1],xpath,k);

			} else{

				String ioe = "filenames do not correspond : "+
				"gtFilename : "+gtFilenames[k]+" outputFilename : "+outputFilenames[k];

				throw new IOException ( ioe ) ;				


			}
		}

		
	}

	public static String readFile(String path){
			try{
  				byte[] encoded = Files.readAllBytes(Paths.get(path));
 				return new String(encoded, "UTF-8");
			}
			catch(IOException ioe){
				ioe.printStackTrace();
				return null;
			}
	}



	public CitationsPair [] getCitationsPairs(){
		return citPairs;
	}

}
