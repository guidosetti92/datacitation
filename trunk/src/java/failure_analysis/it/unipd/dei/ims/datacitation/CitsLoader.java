package it.unipd.dei.ims.datacitation;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.File ;
import java.nio.file.Files ;
import java.nio.file.StandardCopyOption;
import java.nio.file.Paths ;  
import java.io.IOException;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

import it.unipd.dei.ims.datacitation.config.InitDataCitation;

import it.unipd.dei.ims.datacitation.parser.XMLDomParser;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import org.w3c.dom.NamedNodeMap;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathConstants;


import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;


import it.unipd.dei.ims.datacitation.buildcitation.PathMatcher;
import it.unipd.dei.ims.datacitation.buildcitation.ReferenceBuilder;
import it.unipd.dei.ims.datacitation.citationprocessing.PathProcessor;

public class CitsLoader  {

	//the groundtruth eadfiles folder
	private String EadFolderPath ;


	//the machine readable references of the ground truth 
	private String gtTestFolderPath ;
	//the output machine readable references generated by the "learning to cite" framework
	private String outputFolderPath ;

	private String [] gtFilePaths ;
	private String [] outputFilePaths;
	private String [] gtFilenames ;
	private String [] outputFilenames;
	
	private Document citationModel ; //the model with which the citations have been built 
	private File 	citationModelFile;
	private ArrayList<Citation> cits ; 

	private String propFilePath;

	


	public CitsLoader () throws IOException {
		InitDataCitation prop = new InitDataCitation();
		
		try {
			prop.loadProperties();
		} catch (IOException e) {
			e.printStackTrace();
		}
		EadFolderPath = prop.getProperty ( "datacitation.path.testset");
		gtTestFolderPath = prop.getProperty ("datacitation.path.testset") + "_machine_ref";
		outputFolderPath = prop.getProperty ("datacitation.path.outputDir");
		/*
		System.out.println(gtEadFolderPath);
		System.out.println(gtTestFolderPath);
		System.out.println(outputFolderPath);
		*/
		
		File gtTestFolder = new File (gtTestFolderPath);
		File outputFolder = new File (outputFolderPath) ;

		int gtFilesNum = 0; 
		int outputFilesNum = 0  ;
		
		System.out.println(gtTestFolderPath);
		for ( final File f : gtTestFolder.listFiles()){
			if ( f.exists() && !f.isHidden())
				gtFilesNum++;
		}
		
		for ( final File f : outputFolder.listFiles()){
			if ( f.exists() && !f.isHidden() && f.getName().endsWith(".txt"))
				outputFilesNum++;
		}
		
		int filesNum = 0; 
		if ( gtFilesNum != outputFilesNum ) {
			String e = "the ground truth and output folders have a different number of files. "+
			gtFilesNum+" "+outputFilesNum+" ";
			throw new IOException(e);

		}else{
			filesNum = gtFilesNum;
		}
		
		filesNum = outputFilesNum;
		gtFilePaths = new String [filesNum];
		outputFilePaths = new String [filesNum];
		gtFilenames = new String [filesNum];
		outputFilenames = new String [filesNum];
		
		int i = 0 ; 
		for ( final File f : gtTestFolder.listFiles()){
			if ( f.exists() && !f.isHidden()){
				gtFilePaths[i] = f.getAbsolutePath();
				gtFilenames[i] = f.getName();
				i++;
			}
		}
		i = 0 ;
		for ( final File f : outputFolder.listFiles()){
			if ( f.exists() && !f.isHidden() && f.getName().endsWith(".txt")){
				outputFilePaths[i] = f.getAbsolutePath();
				outputFilenames[i] = f.getName();
				i++;
			}

			if ( f.getName().endsWith("xml")) this.citationModelFile = new File(f.getAbsolutePath());

			if ( f.getName().endsWith("properties")) this.propFilePath = f.getAbsolutePath();

			
		}

		Arrays.sort(gtFilePaths);Arrays.sort(gtFilenames);
		Arrays.sort(outputFilePaths);Arrays.sort(outputFilenames);
		/*
		for ( int j = 0 ; j < gtFilePaths.length ; j++ ) {

			System.out.println("gtFilePaths["+Integer.toString(j)+"] : "+gtFilePaths[j]) ;
			System.out.println("outputFilePaths["+Integer.toString(j)+"] : "+outputFilePaths[j]) ;
		}
		*/
		


		
		cits = new ArrayList< Citation > ();


		//System.out.println(citationModelFile.getAbsolutePath());
		try{
			 citationModel = XMLDomParser.getDom(citationModelFile);
		}catch(org.xml.sax.SAXException s){
			s.printStackTrace();
			return ; 
		}catch (IOException ioe ){
			ioe.printStackTrace();
			return ; 
		}catch(javax.xml.parsers.ParserConfigurationException pe){
			pe.printStackTrace();
			return ; 
		}

		//System.out.println(citationModel);


		for ( int k = 0 ; k < outputFilePaths.length;k++ ){
			String gtmr = readFile(gtFilePaths[k]);
			String mr = readFile(outputFilePaths[k]);
			//String [] gtsplt = gtFilenames[k].split("-");
			String [] splt = outputFilenames[k].split("-");


			String onlyHaNA = "" ;

			if ( splt[1].contains("HaNA")) onlyHaNA = "-"+splt[2];

			String xpathFilePath = prop.getProperty("datacitation.path.testset") + "_XPath/"+
			splt[0]+"-"+splt[1]+onlyHaNA+"-xpath.txt";

			//System.out.println(xpathFilePath);

			String xpath = readFile(xpathFilePath);

			if ( splt[1].contains("HaNA")) onlyHaNA = "-"+splt[1]; else onlyHaNA = "";
			

			String eadFilePath = EadFolderPath+"/"+splt[0]+onlyHaNA+".xml";

			cits.add(new Citation(gtmr,mr,eadFilePath,citationModel,citationModelFile,splt[0]+"-"+splt[1],xpath,k));			

			
			/*
			if (gtsplt[0].equals(splt[0]) && gtsplt[1].equals(splt[1]) ){

				String onlyHaNA = "" ;

				if ( gtsplt[1].contains("HaNA")) onlyHaNA = "-"+gtsplt[2];

				String xpathFilePath = prop.getProperty("datacitation.path.testset") + "_XPath/"+
				splt[0]+"-"+splt[1]+onlyHaNA+"-xpath.txt";

				System.out.println(xpathFilePath);

				String xpath = readFile(xpathFilePath);

				if ( gtsplt[1].contains("HaNA")) onlyHaNA = "-"+gtsplt[1]; else onlyHaNA = "";
				String eadFilePath = gtEadFolderPath+"/"+gtsplt[0]+onlyHaNA+".xml";

				citPairs[k] = new CitationsPair(gtmr,mr,eadFilePath,gtsplt[0]+"-"+gtsplt[1],xpath,k);

			} else{

				String ioe = "filenames do not correspond : "+
				"gtFilename : "+gtFilenames[k]+" outputFilename : "+outputFilenames[k];

				throw new IOException ( ioe ) ;				


			}
			*/
		}


		
	}

	public static String readFile(String path){
			try{
  				byte[] encoded = Files.readAllBytes(Paths.get(path));
 				return new String(encoded, "UTF-8");
			}
			catch(IOException ioe){
				ioe.printStackTrace();
				return null;
			}
	}


	public String getOptimizationMeasure(){

		
		InitDataCitation modelProp = new InitDataCitation();

		//propfilepath = "resources/dataCitation-"+optimizationMeasure+".properties";
		//System.out.println(propFilePath);
		String propToLoad ="resources/"+new File(propFilePath).getName();
		try{
			Files.copy(Paths.get(propFilePath),Paths.get(propToLoad),
							StandardCopyOption.REPLACE_EXISTING);
		}catch(IOException ioe){
			ioe.printStackTrace();
		}


		try {
			modelProp.loadProperties(new File(propFilePath).getName());
		} catch (IOException e) {
			e.printStackTrace();
		}

		return modelProp.getProperty("datacitation.training.optimizationMeasure");

	}



	public ArrayList<Citation> getCitations(){
		return cits;
	}

	


	public Citation cite(Citation cit){
		

		String XPath  = cit.getXPathCited();

		String eadFilePath = cit.getEADFilePath();


		System.out.println("citing citation : "+cit.getIndex());

		
		InitDataCitation prop = new InitDataCitation();
		
		try {
			prop.loadProperties();
		} catch (IOException e) {
			e.printStackTrace();
		}


		//save the model to resource so it can be used to cite an XPath
		try{
			DOMSource domSource = new DOMSource(citationModel);
			Transformer transformer = TransformerFactory.newInstance().newTransformer();
			transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "no");
			transformer.setOutputProperty(OutputKeys.METHOD, "xml");
			transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
			transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			FileWriter swW = new FileWriter(new File ( "resources/"+citationModelFile.getName()+".modified"));
			BufferedWriter sw = new BufferedWriter(swW);
			StreamResult sr = new StreamResult(sw);
			transformer.transform(domSource, sr);
			sw.flush();
			sw.close();
		}catch(Exception e ){
			e.printStackTrace();
		}




		String [] props = {"datacitation.bestMatch.minRatio","datacitation.citableunit.weightingFunction",
					"datacitation.citableunit.scoreThreshold"};
		
		/*
		for ( String p : props ){
			System.out.println(p+" "+prop.getProperty(p));

		}*/

		
		InitDataCitation modelProp = new InitDataCitation();

		//propfilepath = "resources/dataCitation-"+optimizationMeasure+".properties";
		//System.out.println(propFilePath);
		String propToLoad ="resources/"+new File(propFilePath).getName();
		try{
			Files.copy(Paths.get(propFilePath),Paths.get(propToLoad),
							StandardCopyOption.REPLACE_EXISTING);
		}catch(IOException ioe){
			ioe.printStackTrace();
		}


		try {
			modelProp.loadProperties(new File(propFilePath).getName());
		} catch (IOException e) {
			e.printStackTrace();
		}

		for ( String p : props ){
			//System.out.println(p+" "+modelProp.getProperty(p));
			prop.setProperty(p,modelProp.getProperty(p));
		}

		prop.setProperty("datacitation.citationtree.file","resources/"+citationModelFile.getName()+".modified");


		try{
			prop.saveProperties();
		}catch(IOException ioe){
			ioe.printStackTrace();
		}

		


		XPath xPath = XPathFactory.newInstance().newXPath();
		
		String xpte ="/"+XPath ; 

		Document EAD ;
		try{
			 EAD = XMLDomParser.getDom(new File(eadFilePath));
		}catch(org.xml.sax.SAXException s){
			s.printStackTrace();
			return null; 
		}catch (IOException ioe ){
			ioe.printStackTrace();
			return null; 
		}catch(javax.xml.parsers.ParserConfigurationException pe){
			pe.printStackTrace();
			return null; 
		}



		try{	
			Node node = (Node)xPath.evaluate(xpte, EAD.getDocumentElement(), XPathConstants.NODE);

			if ( node != null ) {


				String xPathNode  = xpte;

				//System.out.println(xPathNode);

				PathProcessor p = new PathProcessor(xPathNode);

				PathMatcher match = new PathMatcher(p.getProcessedPath());

				ArrayList<String> paths = match.getCandidatePaths();

				ReferenceBuilder refB = new ReferenceBuilder(xPathNode, eadFilePath,paths);

				refB.buildReference();

				String mr = refB.getMachineReadableReference();
				String filename = new File(eadFilePath).getName().replace(".xml","");
				
				//System.out.println(refB.getMachineReadableReference());
				//Citation(mr,eadFilePath,citationModel,citationModelFile,splt[0]+"-"+splt[1],xpath,k));
				Citation newCit = new Citation(cit.getgtmachineReference(),mr,eadFilePath,citationModel,citationModelFile,filename,xpte,cits.size());
				//this.cits.add( newCit );

				return newCit;

			}else{

				//System.out.println("xpath not found");
				return null ;
			}
			
		}catch(Exception e){
			e.printStackTrace();
		}
		return null;


	}



}
